"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SortedItemRepository = void 0;
const ioredis_1 = require("ioredis");
const msgpack_1 = require("@msgpack/msgpack");
const repository_1 = require("./repository");
class SortedItemRepository {
    constructor(name, redis = new ioredis_1.Redis()) {
        this.name = name;
        this.redis = redis;
        this.keyPrefix = `items:${name}:`;
        this.hashPrefix = `items-data:${name}:`;
    }
    set(item) {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.hasItem(item.id)) {
                yield this.redis.zrem(this.keyPrefix, item.id);
            }
            const score = Number(process.hrtime.bigint());
            const buffer = (0, msgpack_1.encode)(item);
            yield Promise.all([
                yield this.redis.hset(this.hashPrefix, item.id, Buffer.from(buffer)),
                yield this.redis.zadd(this.keyPrefix, score, item.id)
            ]);
        });
    }
    getById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = yield this.redis.hgetBuffer(this.hashPrefix, id);
            return (0, repository_1.bufferToItem)(payload);
        });
    }
    getAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.redis.zrange(this.keyPrefix, 0, -1);
            if (keys.length === 0) {
                return [];
            }
            const buffers = yield this.redis.hmgetBuffer(this.hashPrefix, ...keys);
            return buffers.map((b) => (0, repository_1.bufferToItem)(b));
        });
    }
    getItemScoreById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const score = yield this.redis.zscore(this.keyPrefix, id);
            return score ? Number(score) : null;
        });
    }
    getItemsByScore(min, max) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.redis.zrangebyscore(this.keyPrefix, min, max);
            if (keys.length === 0) {
                return [];
            }
            const buffers = yield this.redis.hmgetBuffer(this.hashPrefix, ...keys);
            const items = buffers.map((b) => (0, repository_1.bufferToItem)(b));
            return items;
        });
    }
    getPaginated(page, pageSize) {
        return __awaiter(this, void 0, void 0, function* () {
            const count = yield this.redis.zcard(this.keyPrefix);
            const start = (page - 1) * pageSize;
            const end = start + pageSize - 1;
            const keys = yield this.redis.zrange(this.keyPrefix, start, end);
            if (keys.length === 0) {
                return {
                    items: [],
                    count: 0
                };
            }
            const buffers = yield this.redis.hmgetBuffer(this.hashPrefix, ...keys);
            const items = buffers.map((b) => (0, repository_1.bufferToItem)(b));
            return {
                items,
                count
            };
        });
    }
    deletePage(page, pageSize) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = (page - 1) * pageSize;
            const end = start + pageSize - 1;
            const keys = yield this.redis.zrange(this.keyPrefix, start, end);
            if (keys.length > 0) {
                yield Promise.all([this.redis.zrem(this.keyPrefix, ...keys), this.redis.hdel(this.hashPrefix, ...keys)]);
            }
        });
    }
    hasItem(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.redis.hexists(this.hashPrefix, id)) === 1;
        });
    }
    deleteById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([this.redis.zrem(this.keyPrefix, id), this.redis.hdel(this.hashPrefix, id)]);
        });
    }
    count() {
        return __awaiter(this, void 0, void 0, function* () {
            const count = yield this.redis.zcard(this.keyPrefix);
            return count;
        });
    }
    deleteAll() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([yield this.redis.del(this.hashPrefix), yield this.redis.del(this.keyPrefix)]);
        });
    }
    getFirstNItems(n) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.redis.zrange(this.keyPrefix, 0, n - 1);
            if (keys.length === 0) {
                return [];
            }
            const buffers = yield this.redis.hmgetBuffer(this.hashPrefix, ...keys);
            return buffers.map((b) => (0, repository_1.bufferToItem)(b));
        });
    }
    getLastNItems(n) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.redis.zrevrange(this.keyPrefix, 0, n - 1);
            if (keys.length === 0) {
                return [];
            }
            const buffers = yield this.redis.hmgetBuffer(this.hashPrefix, ...keys);
            return buffers.map((b) => (0, repository_1.bufferToItem)(b)).reverse();
        });
    }
    getItemsInRange(start, end) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.redis.zrange(this.keyPrefix, start, end);
            if (keys.length === 0) {
                return [];
            }
            const buffers = yield this.redis.hmgetBuffer(this.hashPrefix, ...keys);
            return buffers.map((b) => (0, repository_1.bufferToItem)(b));
        });
    }
    existsInRange(min, max) {
        return __awaiter(this, void 0, void 0, function* () {
            const count = yield this.redis.zcount(this.keyPrefix, min, max);
            return count > 0;
        });
    }
    getNextNItemsGreaterThanScore(score, n) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.redis.zrangebyscore(this.keyPrefix, `(${score}`, '+inf', 'LIMIT', 0, n);
            if (keys.length === 0) {
                return [];
            }
            const buffers = yield this.redis.hmgetBuffer(this.hashPrefix, ...keys);
            return buffers.map((b) => (0, repository_1.bufferToItem)(b));
        });
    }
}
exports.SortedItemRepository = SortedItemRepository;
exports.default = SortedItemRepository;
